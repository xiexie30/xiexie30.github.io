[{"title":"函数收集","date":"2022-09-18T11:00:00.000Z","path":"2022/09/18/函数收集/","text":"1.计时器123456789101112131415161718192021222324252627# 计时器class Timer: #@save &quot;&quot;&quot;记录多次运行时间&quot;&quot;&quot; def __init__(self): self.times = [] self.start() def start(self): &quot;&quot;&quot;启动计时器&quot;&quot;&quot; self.tik = time.time() def stop(self): &quot;&quot;&quot;停止计时器并将时间记录在列表中&quot;&quot;&quot; self.times.append(time.time() - self.tik) return self.times[-1] def avg(self): &quot;&quot;&quot;返回平均时间&quot;&quot;&quot; return sum(self.times) / len(self.times) def sum(self): &quot;&quot;&quot;返回时间总和&quot;&quot;&quot; return sum(self.times) def cumsum(self): &quot;&quot;&quot;返回累计时间&quot;&quot;&quot; return np.array(self.times).cumsum().tolist() 2.Accumulator，数值累加器12345678910111213class Accumulator: #@save &quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot; def __init__(self, n): self.data = [0.0] * n def add(self, *args): self.data = [a + float(b) for a, b in zip(self.data, args)] def reset(self): self.data = [0.0] * len(self.data) def __getitem__(self, idx): return self.data[idx] 3.weight_init12345678910def weight_init(m): &quot;&quot;&quot;网络初始化&quot;&quot;&quot; if isinstance(m, nn.Linear): nn.init.xavier_normal_(m.weight) nn.init.constant_(m.bias, 0) elif isinstance(m, nn.Conv2d): nn.init.kaiming_normal_(m.weight, mode=&#x27;fan_out&#x27;, nonlinearity=&#x27;relu&#x27;) elif isinstance(m, nn.BatchNorm2d): nn.init.constant_(m.weight, 1) nn.init.constant_(m.bias, 0) 4.print网络每层输出1234X = torch.randn(1, 1, 224, 224) for layer in net: X=layer(X) print(layer.__class__.__name__,&#x27;output shape:\\t&#x27;,X.shape) 5.显示矩阵热力图12345678910111213141516171819202122#@savedef show_heatmaps(matrices, xlabel, ylabel, titles=None, figsize=(2.5, 2.5), cmap=&#x27;Reds&#x27;): &quot;&quot;&quot;显示矩阵热图&quot;&quot;&quot; d2l.use_svg_display() num_rows, num_cols = matrices.shape[0], matrices.shape[1] fig, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize, sharex=True, sharey=True, squeeze=False) for i, (row_axes, row_matrices) in enumerate(zip(axes, matrices)): for j, (ax, matrix) in enumerate(zip(row_axes, row_matrices)): pcm = ax.imshow(matrix.detach().numpy(), cmap=cmap) if i == num_rows - 1: ax.set_xlabel(xlabel) if j == 0: ax.set_ylabel(ylabel) if titles: ax.set_title(titles[j]) fig.colorbar(pcm, ax=axes, shrink=0.6);# 输入维度attention_weights = torch.eye(10).reshape((1, 1, 10, 10))show_heatmaps(attention_weights, xlabel=&#x27;Keys&#x27;, ylabel=&#x27;Queries&#x27;)","link":"","tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://xiexie30.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"AD","slug":"AD","permalink":"http://xiexie30.github.io/tags/AD/"}]},{"title":"Hello World","date":"2022-09-18T08:56:58.520Z","path":"2022/09/18/hello-world/","text":"Hellow World!","link":"","tags":[]}]